# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kCO2cuJ9GHzVpDJ7fnfovRKfO7sEJk9b
"""

pip install streamlit

"""
illiquid_option_sim_full.py

Educational simulation of an illiquid option market with:
 - interactive controls (Streamlit sliders / inputs),
 - a multi-level limit order book (LOB) and multiple liquidity providers,
 - a human trader who places buy orders with adjustable aggression,
 - a market-maker (MM) quoting and managing inventory,
 - live plots and trade-by-trade analytics: P&L, slippage, inventory, volume.

IMPORTANT SAFETY NOTE:
This is for teaching/research/visualization only. It intentionally DOES NOT provide
step-by-step instructions for manipulating real markets. Use responsibly.

Run:
 pip install streamlit numpy pandas plotly
 streamlit run illiquid_option_sim_full.py
"""

import streamlit as st
import numpy as np
import pandas as pd
import time
import plotly.graph_objs as go
from collections import deque, defaultdict

# ---------------------------
# Helper classes and functions
# ---------------------------

class LimitOrderBook:
    """
    Very simple limit order book with discrete price levels and FIFO within level.
    buy_orders and sell_orders are dict: price -> deque of (id, size, owner)
    """
    def __init__(self, price_tick=1.0):
        self.price_tick = price_tick
        self.buy_orders = defaultdict(deque)   # key: price, value: deque of (id, size, owner)
        self.sell_orders = defaultdict(deque)
        self.order_id_counter = 0

    def _next_id(self):
        self.order_id_counter += 1
        return self.order_id_counter

    def add_limit_order(self, side, price, size, owner="LP"):
        oid = self._next_id()
        if side == "buy":
            self.buy_orders[price].append({'id': oid, 'size': size, 'owner': owner})
        else:
            self.sell_orders[price].append({'id': oid, 'size': size, 'owner': owner})
        return oid

    def match_market_order(self, side, size):
        """
        Execute market order of given size against book.
        Returns list of fills: (price, executed_size, owner)
        """
        fills = []
        remaining = size
        if side == "buy":
            # buy market consumes from sell side (lowest asks first)
            ask_prices = sorted(self.sell_orders.keys())
            for p in ask_prices:
                if remaining <= 0:
                    break
                queue = self.sell_orders[p]
                while queue and remaining > 0:
                    top = queue[0]
                    take = min(remaining, top['size'])
                    fills.append((p, take, top['owner']))
                    top['size'] -= take
                    remaining -= take
                    if top['size'] <= 1e-9:
                        queue.popleft()
                if not queue:
                    del self.sell_orders[p]
        else:
            # sell market consumes from buy side (highest bids first)
            bid_prices = sorted(self.buy_orders.keys(), reverse=True)
            for p in bid_prices:
                if remaining <= 0:
                    break
                queue = self.buy_orders[p]
                while queue and remaining > 0:
                    top = queue[0]
                    take = min(remaining, top['size'])
                    fills.append((p, take, top['owner']))
                    top['size'] -= take
                    remaining -= take
                    if top['size'] <= 1e-9:
                        queue.popleft()
                if not queue:
                    del self.buy_orders[p]
        return fills, size - remaining  # fills list and executed size

    def best_bid(self):
        if not self.buy_orders:
            return None
        return max(self.buy_orders.keys())

    def best_ask(self):
        if not self.sell_orders:
            return None
        return min(self.sell_orders.keys())

    def snapshot_depth(self, depth=10):
        """
        Returns ordered lists for plotting:
         bids (price desc, size sum), asks (price asc, size sum)
        """
        bids = sorted(self.buy_orders.items(), key=lambda x: x[0], reverse=True)[:depth]
        asks = sorted(self.sell_orders.items(), key=lambda x: x[0])[:depth]
        bid_prices = [p for p, q in bids]
        bid_sizes = [sum(item['size'] for item in q) for p, q in bids]
        ask_prices = [p for p, q in asks]
        ask_sizes = [sum(item['size'] for item in q) for p, q in asks]
        return bid_prices, bid_sizes, ask_prices, ask_sizes

    def book_size(self):
        return sum(sum(item['size'] for item in q) for q in self.buy_orders.values()) + \
               sum(sum(item['size'] for item in q) for q in self.sell_orders.values())

# ---------------------------
# Streamlit UI
# ---------------------------

st.set_page_config(layout="wide", page_title="Illiquid Option Market Simulator (Educational)")

st.title("Illiquid Option Market Simulator — Educational")
st.markdown(
    """
**Safety note:** This simulation is intentionally high-level and stochastic. It's for learning how liquidity,
order books, and inventory management interact. It does **not** teach or encourage market manipulation.
"""
)

# Layout: left sidebar for controls, main columns for charts and tables
with st.sidebar:
    st.header("Simulation controls")

    # Market params
    fair_value_init = st.number_input("Initial fair value (₹)", value=40.0, step=1.0)
    tick = st.number_input("Price tick (₹)", value=1.0, step=0.1)
    base_spread = st.number_input("Base half-spread (₹)", value=4.0, step=0.5)
    initial_mm_bid = st.number_input("Initial MM bid (₹)", value=20.0, step=1.0)
    initial_mm_ask = st.number_input("Initial MM ask (₹)", value=80.0, step=1.0)

    # Liquidity providers (LPs)
    st.subheader("Liquidity providers (standing book)")
    n_lps = st.slider("Number of passive LPs", min_value=1, max_value=6, value=3)
    lp_depth = st.slider("Price levels per LP", min_value=3, max_value=12, value=6)
    lp_size_mean = st.number_input("LP size per level (mean)", value=3.0, step=0.5)
    lp_size_sd = st.number_input("LP size per level (sd)", value=1.0, step=0.1)

    # Market-maker / algo params
    st.subheader("Market-maker (active) params")
    mm_inventory_limit = st.number_input("MM inventory limit (contracts)", value=25.0, step=1.0)
    mm_inventory_sensitivity = st.number_input("MM inventory sensitivity", value=0.12, step=0.01)
    mm_reaction_speed = st.slider("MM reaction aggressiveness (0 slow - 1 fast)", 0.0, 1.0, 0.5)

    # Human trader params
    st.subheader("Human trader params")
    human_base_prob = st.number_input("Human base action prob (per step)", value=0.05, step=0.01)
    human_aggression = st.number_input("Human aggression (%) per failed attempt", value=1.5, step=0.1) / 100.0
    human_size_mean = st.number_input("Human order size mean", value=1.0, step=0.1)
    human_size_sd = st.number_input("Human order size sd", value=0.4, step=0.1)
    human_mode = st.selectbox("Human order type", ["limit buys", "market lifts", "mixed"], index=2)

    # Simulation controls
    st.subheader("Run control")
    steps = st.slider("Simulation steps per run", 50, 2000, 400)
    speed_ms = st.slider("Milliseconds between frames (visual)", 10, 1000, 120)
    run_button = st.button("Run simulation (one run)")

st.markdown("---")

# Main columns
col1, col2 = st.columns((2, 1))

# Initialize placeholders
price_chart_ph = col1.empty()
lob_chart_ph = col2.empty()
inventory_chart_ph = col1.empty()
volume_chart_ph = col1.empty()
pnl_chart_ph = col2.empty()
trade_log_ph = st.expander("Trade log / last trades", expanded=False)

# ---------------------------
# Preparation: create LOB and seed standing liquidity
# ---------------------------

LOB = LimitOrderBook(price_tick=tick)

def seed_lps(LOB, fair_value, n_lps=3, depth=6, size_mean=3.0, size_sd=1.0):
    """
    Create passive limit orders on both sides around fair_value from multiple LPs.
    """
    LOB.buy_orders.clear()
    LOB.sell_orders.clear()
    owners = [f"LP{i+1}" for i in range(n_lps)]
    half_spread = base_spread
    # place symmetric levels
    for owner in owners:
        for level in range(1, depth + 1):
            # price offsets
            bid_price = round(fair_value - (half_spread + (level-1) * tick), 8)
            ask_price = round(fair_value + (half_spread + (level-1) * tick), 8)
            # randomize sizes
            bsize = max(0.1, np.random.normal(size_mean, size_sd))
            asize = max(0.1, np.random.normal(size_mean, size_sd))
            LOB.add_limit_order("buy", bid_price, bsize, owner=owner)
            LOB.add_limit_order("sell", ask_price, asize, owner=owner)

# seed initial LOB
seed_lps(LOB, fair_value_init, n_lps=n_lps, depth=lp_depth, size_mean=lp_size_mean, size_sd=lp_size_sd)

# ---------------------------
# Simulation engine
# ---------------------------

def run_simulation(params):
    """
    Runs the simulation and returns a DataFrame of time series + trade history.
    """
    (steps, fair_init, tick, base_spread, initial_mm_bid, initial_mm_ask,
     n_lps, lp_depth, lp_size_mean, lp_size_sd,
     mm_inventory_limit, mm_inv_sens, mm_reaction_speed,
     human_base_prob, human_aggression, human_size_mean, human_size_sd, human_mode) = params

    # fresh LOB
    lob = LimitOrderBook(price_tick=tick)
    seed_lps(lob, fair_init, n_lps=n_lps, depth=lp_depth, size_mean=lp_size_mean, size_sd=lp_size_sd)

    # state variables
    fair_value = fair_init
    mm_inventory = 0.0
    last_trade_price = fair_value
    cumulative_volume = 0.0
    human_bid_price = initial_mm_bid + 1.0  # initial human willingness
    mm_mid = (initial_mm_bid + initial_mm_ask) / 2.0

    # records
    rows = []
    trades = []

    for t in range(steps):
        # 1) Occasionally nudge fair value (news)
        if np.random.rand() < 0.01:
            fair_value += np.random.normal(0.0, 1.0)

        # 2) MM updates quotes: the MM behaves as an active liquidity provider that posts a one-level limit order
        # Determine desired mid centered on fair_value adjusted by inventory
        shift = mm_inv_sens * mm_inventory
        desired_mid = fair_value - shift
        # MM posts a single bid and ask (acts as active algo)
        mm_bid = round(desired_mid - base_spread * (1 - mm_reaction_speed), 8)
        mm_ask = round(desired_mid + base_spread * (1 - mm_reaction_speed), 8)
        # To model a MM's posted depth, insert single-level orders owned by "MM"
        # Clear any previous MM orders at these exact prices (to keep it simple)
        # We won't track removal: instead we just add a shallow MM size at those prices each t
        mm_level_size = max(0.2, 2.0 * mm_reaction_speed)
        lob.add_limit_order("buy", mm_bid, mm_level_size, owner="MM")
        lob.add_limit_order("sell", mm_ask, mm_level_size, owner="MM")

        # 3) Human decides to act
        prob = human_base_prob + 0.001 * max(0.0, (human_bid_price - initial_mm_bid))
        acted = False
        if np.random.rand() < prob:
            acted = True
            size = max(0.1, np.random.normal(human_size_mean, human_size_sd))
            # Determine style: market lift vs limit buy
            if human_mode == "market lifts":
                # human sends a market buy -> consumes asks
                fills, executed = lob.match_market_order("buy", size)
                for p, s, owner in fills:
                    trades.append({
                        "t": t, "side": "buy", "price": p, "size": s, "participant": "Human",
                        "received_from": owner
                    })
                    # adjust inventory: MM sells reduces MM inventory; if owner was LP, their inventory would change too
                    if owner == "MM":
                        mm_inventory -= s
                    cumulative_volume += s
                    last_trade_price = p
                # if executed == 0 -> no liquidity, human raises limit willingness
                if executed == 0:
                    human_bid_price *= (1.0 + human_aggression)
            elif human_mode == "limit buys":
                # place a passive buy limit at human_bid_price
                lob.add_limit_order("buy", human_bid_price, size, owner="Human")
            else:  # mixed
                if np.random.rand() < 0.6:
                    # market lift
                    fills, executed = lob.match_market_order("buy", size)
                    for p, s, owner in fills:
                        trades.append({
                            "t": t, "side": "buy", "price": p, "size": s, "participant": "Human",
                            "received_from": owner
                        })
                        if owner == "MM":
                            mm_inventory -= s
                        cumulative_volume += s
                        last_trade_price = p
                    if executed == 0:
                        human_bid_price *= (1.0 + human_aggression)
                else:
                    lob.add_limit_order("buy", human_bid_price, size, owner="Human")

        # 4) Passive LPs may occasionally cancel/add depth to mimic thin book dynamics
        if np.random.rand() < 0.03:
            # randomly add or remove one LP level
            if np.random.rand() < 0.6:
                # add a small standing ask or bid
                p = round(fair_value + base_spread + np.random.randint(0, lp_depth) * tick, 8)
                lob.add_limit_order("sell", p, max(0.1, np.random.normal(lp_size_mean, lp_size_sd)), owner=f"LP{np.random.randint(1, n_lps+1)}")
            else:
                # add buy side
                p = round(fair_value - base_spread - np.random.randint(0, lp_depth) * tick, 8)
                lob.add_limit_order("buy", p, max(0.1, np.random.normal(lp_size_mean, lp_size_sd)), owner=f"LP{np.random.randint(1, n_lps+1)}")

        # 5) MM risk rebalancing: if inventory beyond limit, MM sends market trades to reduce exposure
        if mm_inventory > mm_inventory_limit:
            sell_to_reduce = min(mm_inventory - mm_inventory_limit, 3.0)
            fills, executed = lob.match_market_order("sell", sell_to_reduce)
            for p, s, owner in fills:
                trades.append({
                    "t": t, "side": "sell", "price": p, "size": s, "participant": "MM",
                    "received_from": owner
                })
                # if owner was LP then MM buys from them and inventory reduces (i.e., buys reduce negative inventory)
                if owner == "LP1" or owner.startswith("LP") or owner == "MM":
                    # MM placed a market sell -> reduces its inventory (because sells)
                    mm_inventory -= s  # selling reduces inventory
                cumulative_volume += s
                last_trade_price = p
        elif mm_inventory < -mm_inventory_limit:
            buy_to_reduce = min(-mm_inventory - mm_inventory_limit, 3.0)
            fills, executed = lob.match_market_order("buy", buy_to_reduce)
            for p, s, owner in fills:
                trades.append({
                    "t": t, "side": "buy", "price": p, "size": s, "participant": "MM",
                    "received_from": owner
                })
                if owner == "MM":
                    mm_inventory += s
                cumulative_volume += s
                last_trade_price = p

        # 6) Small stochastic inventory changes to reflect other market flows
        mm_inventory += np.random.normal(0.0, 0.05 * (1 + mm_reaction_speed))

        # 7) record snapshot
        best_bid = lob.best_bid()
        best_ask = lob.best_ask()
        mid = (best_bid + best_ask) / 2.0 if (best_bid is not None and best_ask is not None) else np.nan

        rows.append({
            "t": t,
            "fair_value": fair_value,
            "best_bid": best_bid if best_bid is not None else np.nan,
            "best_ask": best_ask if best_ask is not None else np.nan,
            "mid": mid,
            "mm_inventory": mm_inventory,
            "cum_volume": cumulative_volume,
            "human_bid_price": human_bid_price,
            "lob_book_size": lob.book_size()
        })

    df = pd.DataFrame(rows)
    trades_df = pd.DataFrame(trades)
    return df, trades_df, lob

# ---------------------------
# Run & visualize one simulation
# ---------------------------

if run_button:
    params = (
        steps, fair_value_init, tick, base_spread, initial_mm_bid, initial_mm_ask,
        n_lps, lp_depth, lp_size_mean, lp_size_sd,
        mm_inventory_limit, mm_inventory_sensitivity, mm_reaction_speed,
        human_base_prob, human_aggression, human_size_mean, human_size_sd, human_mode
    )
    with st.spinner("Running simulation… (this may take a few seconds)"):
        df_ts, trades_df, lob = run_simulation(params)

    st.success("Simulation run complete — visualizing results")

    # Compute trade-by-trade P&L for Human and MM (naive approach)
    if not trades_df.empty:
        trades_df['notional'] = trades_df['price'] * trades_df['size']
        # assign sign by side
        trades_df['signed_size'] = trades_df['size'] * trades_df['side'].map({'buy': 1, 'sell': -1})
        # cumulative position by participant
        trades_df['cum_pos'] = trades_df.groupby('participant')['signed_size'].cumsum()
        # assume fair_value at trade time is benchmark for mark-to-market P&L:
        # we compute realized P&L only (cashflows), and track inventory for unrealized optionally.
        # Realized P&L: sell proceeds minus buy costs (per participant)
        realized = []
        pnl_by_participant = {}
        # simple realized P&L via running FIFO per participant (small utility)
        def compute_realized_pnl(part_trades):
            # trades: chronological for the participant
            pos_stack = []  # list of (size, price) for long positions
            realized = 0.0
            for idx, row in part_trades.iterrows():
                side = row['side']
                price = row['price']
                size = row['size']
                if side == 'buy':
                    pos_stack.append([size, price])
                else:  # sell -> consume long stacks FIFO
                    remaining = size
                    while remaining > 0 and pos_stack:
                        avail, p_buy = pos_stack[0]
                        take = min(avail, remaining)
                        realized += take * (price - p_buy)  # sell - buy
                        pos_stack[0][0] -= take
                        remaining -= take
                        if pos_stack[0][0] <= 1e-9:
                            pos_stack.pop(0)
                    # if no long we assume sell into short (no realized until covered)
                    if remaining > 0:
                        # we allow negative inventory (unrealized) - ignore for realized now
                        pos_stack.insert(0, [-remaining, price])  # short record
                        remaining = 0
            return realized, sum([s * p for s, p in pos_stack])  # realized, unrealized_value (approx)

        participants = trades_df['participant'].unique()
        stats = {}
        for p in participants:
            p_trades = trades_df[trades_df['participant'] == p].copy()
            r, uval = compute_realized_pnl(p_trades)
            stats[p] = {"realized_pnl": r, "unrealized_value_est": uval, "total_traded_qty": p_trades['size'].sum()}

        # show trade table & stats
        with trade_log_ph:
            st.subheader("Recent trades (chronological)")
            st.dataframe(trades_df.tail(200)[['t','participant','side','price','size','received_from']].sort_values(by='t', ascending=False))

        st.subheader("Participant realized P&L (naive FIFO)")
        st.table(pd.DataFrame(stats).T)

    else:
        st.info("No trades executed in this run (book too thin or human didn't act). Try increasing human activity or reducing spread.")

    # Price chart with Plotly
    fig_price = go.Figure()
    fig_price.add_trace(go.Scatter(x=df_ts['t'], y=df_ts['mid'], mode='lines', name='mid', line=dict(width=1)))
    fig_price.add_trace(go.Scatter(x=df_ts['t'], y=df_ts['best_bid'], mode='lines', name='best_bid', line=dict(dash='dot', width=1)))
    fig_price.add_trace(go.Scatter(x=df_ts['t'], y=df_ts['best_ask'], mode='lines', name='best_ask', line=dict(dash='dot', width=1)))
    fig_price.add_trace(go.Scatter(x=df_ts['t'], y=df_ts['fair_value'], mode='lines', name='fair_value', line=dict(dash='dash', width=1)))
    fig_price.update_layout(title="Price evolution (mid / quotes / fair value)", xaxis_title="time step", yaxis_title="Price (₹)", height=350)
    price_chart_ph.plotly_chart(fig_price, use_container_width=True)

    # LOB snapshot (final)
    bid_prices, bid_sizes, ask_prices, ask_sizes = lob.snapshot_depth(depth=20)
    fig_lob = go.Figure()
    if bid_prices:
        fig_lob.add_trace(go.Bar(x=bid_prices, y=bid_sizes, name='bids', orientation='v'))
    if ask_prices:
        fig_lob.add_trace(go.Bar(x=ask_prices, y=ask_sizes, name='asks', orientation='v'))
    fig_lob.update_layout(title="Final LOB depth (price->aggregate size)", xaxis_title="Price", yaxis_title="Size (contracts)", height=350)
    lob_chart_ph.plotly_chart(fig_lob, use_container_width=True)

    # Inventory and volume charts
    fig_inv = go.Figure()
    fig_inv.add_trace(go.Scatter(x=df_ts['t'], y=df_ts['mm_inventory'], mode='lines', name='MM inventory'))
    fig_inv.update_layout(title="MM Inventory over time", xaxis_title="time", yaxis_title="inventory", height=250)
    inventory_chart_ph.plotly_chart(fig_inv, use_container_width=True)

    fig_vol = go.Figure()
    fig_vol.add_trace(go.Scatter(x=df_ts['t'], y=df_ts['cum_volume'], mode='lines', name='cumulative volume'))
    fig_vol.update_layout(title="Cumulative volume", xaxis_title="time", yaxis_title="volume", height=250)
    volume_chart_ph.plotly_chart(fig_vol, use_container_width=True)

    # If trades exist, show a small P&L chart over time per participant
    if not trades_df.empty:
        # compute cumulative realized P&L per participant over time (naive incremental realized)
        trades_df = trades_df.sort_values('t').reset_index(drop=True)
        trades_df['notional'] = trades_df['price'] * trades_df['size']
        # incremental P&L per participant computed by matching buys and sells FIFO is complex in streaming;
        # we'll show simple cashflow P&L (sells are positive cash, buys negative cash) as a proxy.
        trades_df['cashflow'] = trades_df.apply(lambda r: r['price'] * r['size'] * (1 if r['side']=='sell' else -1), axis=1)
        pvt = trades_df.pivot_table(index='t', columns='participant', values='cashflow', aggfunc='sum').fillna(0)
        cum_pnl = pvt.cumsum()
        fig_pnl = go.Figure()
        for col in cum_pnl.columns:
            fig_pnl.add_trace(go.Scatter(x=cum_pnl.index, y=cum_pnl[col].values, mode='lines', name=f"{col} cashflow P&L"))
        fig_pnl.update_layout(title="Participant cumulative cashflow (proxy P&L)", xaxis_title="time", yaxis_title="cashflow P&L", height=350)
        pnl_chart_ph.plotly_chart(fig_pnl, use_container_width=True)

    # Optionally allow download of results
    if st.button("Download results as CSV"):
        csv = df_ts.to_csv(index=False).encode('utf-8')
        st.download_button("Download time series CSV", data=csv, file_name="illiquid_sim_timeseries.csv", mime="text/csv")

    if not trades_df.empty:
        if st.button("Download trades CSV"):
            csv2 = trades_df.to_csv(index=False).encode('utf-8')
            st.download_button("Download trades CSV", data=csv2, file_name="illiquid_sim_trades.csv", mime="text/csv")